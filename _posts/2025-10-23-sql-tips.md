---
layout: post
title: How to make SQL great again!
---
Not doing SQL optimization can clog even a small DB with thousands of rows per table. The reason is often using the SELECT ... FROM (SELECT ..) pattern. Optimization will not only bring it back to life and make calculations almost instant—it will also keep the speed within the seconds range when the data grows 100 times. Here are my tips for SQL optimization. 

The most important are:

1. Use CTEs with the WITH statement.
This way, you can create object-like temporary results you can refer to later and even use multiple times.
Queries at the top should have filters to speed up calculations done below.
It's not only faster, but also more transparent and easier to maintain.
Once you learn it, you will not use SELECT ... FROM (SELECT ..) very often.
This will transform most of your queries into nice joins.

2. Add indexes!
This is a natural step once you learn to use joins instead of the SELECT ... FROM (SELECT ..) pattern.
Indexes should reflect your joins—contain multiple columns for speed, and multiple indexes to support different queries.
Plan it well—indexes used badly can decrease performance (they slow down inserts/updates, as the index must be updated after this operation!).

3. Configure your DB for the purpose.
If your DB is used for analytics, it's a different use case than a regular transactional DB supporting CRM.
CRM DBs must handle many users and a lot of small inserts/updates.
Analytics DBs must handle batch jobs—they require more memory and fewer users/traffic.

For analytical DBs, place them on a machine with lots of RAM.
I recommend a minimum of 32 GB for DBs bigger than 2 GB.
Note: You can have multiple DB processes doing calculations for hundreds of MB when dealing with data marts, so total RAM is important.
Likely, you will have other ETL processes on such a machine.

4. Cache shared extensive calculations using, e.g., materialized views.
This way, you don't need to repeat the same calculations in different places—just do it once for all processes that need it and take data from that source.
Materialized views may be triggered on update, but check how to use them properly—used the wrong way, they can introduce some bad glitches (e.g., if you trigger it a few times within a short period of time).
Alternatively, you can create temporary or permanent tables and refresh them when needed.

5. Build data marts: pre-aggregated results for reporting.
Use materialized views or tables with aggregated results as your final source for reporting.
It will be super fast for user interfaces like Metabase or other reporting tools.
Doing queries directly on raw tables may take seconds even after optimization.
Having it pre-calculated makes it ready when users need it and delivers data in under 1 second.
